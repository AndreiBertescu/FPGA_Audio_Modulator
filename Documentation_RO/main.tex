\documentclass[12pt,a4paper]{report}

% --------------------- PACKAGES ---------------------
\usepackage{fontspec}             % Custom font
\usepackage{pdfpages}             % Atach PDFs
\usepackage{graphicx}             % Images
\usepackage{amsmath,amssymb}      % Math
\usepackage{caption}              % Figure/table captions
\usepackage{subcaption}           % Subfigures
\usepackage{geometry}             % Margins
\usepackage{fancyhdr}             % Headers/footers
\usepackage{tocloft}              % ToC/List formatting
\usepackage[acronym,nonumberlist]{glossaries} % Acronyms
\usepackage[hidelinks]{hyperref}  % Hyperlinks
\usepackage{titlesec}             % Section title styling
\usepackage{listings}             % Source code
\usepackage{chngcntr}             % Counter tweaks
\usepackage{tabularx}             % Tables
\usepackage{tikz}                 % Graphs
\usepackage{pgfplots}             % Plots
\pgfplotsset{compat=1.18}         % Or latest version supported by Overleaf
\usepgfplotslibrary{groupplots}   % Required for group plots
\usepackage{booktabs}             % Better tables
\usepackage{setspace}             % For line spacing
\usepackage{csquotes}             % For biblatex + babel
\usepackage[romanian]{babel}      % For translating bibliography
\usepackage[backend=biber, style=ieee, language=auto]{biblatex} % Bibliography
\addbibresource{references.bib}

% --------------------- FORMAT ---------------------
\setmainfont{UTSans-Regular.otf}[
    Path = Fonts/,
    BoldFont = UTSans-Bold.otf,
    ItalicFont = UTSans-Regular.otf,
    ItalicFeatures={FakeSlant=0.2},
]
\geometry{top=2.5cm, bottom=2cm, left=2.5cm, right=1.5cm}
\setlength{\parindent}{1.25cm}
\linespread{1.2}
\makeglossaries%

% ------- STYLES
\titleformat{\chapter}
    {\normalfont\fontsize{18}{16}\bfseries\selectfont
    \raggedleft\rightskip=0.3cm}
    {\thechapter}{16pt}{\MakeUppercase}
\titlespacing{\chapter}{0pt}{18pt}{8pt}

\titleformat{\section}
    {\normalfont\fontsize{14}{16}\bfseries\selectfont}
    {\thesection}{16pt}{\MakeUppercase}
\titlespacing{\section}{0pt}{18pt}{0pt}

\titleformat{\subsection}
    {\normalfont\fontsize{14}{16}\bfseries\selectfont}
    {\thesubsection}{16pt}{}
\titlespacing{\subsection}{1.25cm}{10pt}{0pt}

\renewcommand{\normalsize}{\fontsize{12}{16}\selectfont}

% ------- HEADER & FOOTER
\pagestyle{fancy}
    \setlength{\headheight}{18pt}
    \setlength{\footskip}{70pt}
    \fancyhf{}
    \fancyhead[L]{
    \ifodd\value{page}{\projecttitle}
    \else\makebox[0pt][l]{\parbox[b]{\headwidth}{\raggedleft{\studentname}}}
    \fi}
    \fancyfoot[C]{\raisebox{15mm}{\thepage}}

\fancypagestyle{plain}{
    \fancyhf{}
    \fancyhead[L]{
    \ifodd\value{page}{\projecttitle}
    \else\makebox[0pt][l]{\parbox[b]{\headwidth}{\raggedleft{\studentname}}}
    \fi}
    \fancyfoot[C]{\raisebox{15mm}{\thepage}}
}

\fancypagestyle{plainfooter}{
  \fancyhf{}
  \renewcommand{\headrulewidth}{0pt}\setlength{\footskip}{70pt}
  \fancyfoot[C]{\raisebox{15mm}{\thepage}}
}

% --------------------- FIGURE, TABLE & CODE STYLES -----------------

% ------- TABLE OF CONTENTS
\renewcommand{\cftchapdotsep}{\cftdotsep}
\setlength{\cftchapnumwidth}{3em}
\renewcommand{\cftchapleader}{\cftdotfill{\cftchapdotsep}}
\AtBeginDocument{\renewcommand\contentsname{}}

% ------- BIBLIOGRAPHY
\defbibheading{bibliography}[\refname]{\chapter{Bibliografie}}
\renewcommand*{\bibfont}{\small}

% ------- FIGURES
\captionsetup{
    font=small,
    labelfont=bf,
    labelsep=period
}

\AtBeginDocument{
    \renewcommand{\figurename}{Figura}
    \counterwithout{figure}{chapter}
    \renewcommand{\listfigurename}{}
    \renewcommand{\cftfigpresnum}{Figura~}
    \renewcommand{\cftfigaftersnum}{.} 
    \settowidth{\cftfignumwidth}{Figură 100.} 
}

% For removing extra space in list of figures
\makeatletter
\def\@chapter[#1]#2{
  \ifnum\c@secnumdepth>\m@ne%
    \refstepcounter{chapter}
    \typeout{\@chapapp\space\thechapter.}
    \addcontentsline{toc}{chapter}{\protect\numberline{\thechapter}#1}
  \else \addcontentsline{toc}{chapter}{#1} \fi
  \chaptermark{#1}
  \addtocontents{lot}{\protect\addvspace{10\p@}}
  \if@twocolumn\@topnewpage[\@makechapterhead{#2}] 
  \else \@makechapterhead{#2} \@afterheading\fi}
\makeatother

% ------- TABLES
\captionsetup[table]{
    justification=raggedleft,
    singlelinecheck=false
}

\AtBeginDocument{
    \counterwithout{table}{chapter}
    \renewcommand{\listtablename}{}
    \renewcommand{\cfttabpresnum}{Tabelul~}
    \renewcommand{\cfttabaftersnum}{.}
    \settowidth{\cfttabnumwidth}{Tabelul 100.}
    \renewcommand{\tablename}{Tabelul}
}

\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}m{#1}}

% For removing extra space in list of tables
\makeatletter
\def\@chapter[#1]#2{
  \ifnum\c@secnumdepth>\m@ne
    \refstepcounter{chapter}
    \typeout{\@chapapp\space\thechapter.}
    \addcontentsline{toc}{chapter}{\protect\numberline{\thechapter}#1}
  \else \addcontentsline{toc}{chapter}{#1} \fi
  \chaptermark{#1}
  \addtocontents{lot}{\protect\addvspace{0pt}}
  \if@twocolumn\@topnewpage[\@makechapterhead{#2}]
  \else\@makechapterhead{#2}\@afterheading\fi}
\makeatother

% ------- SOURCE CODE
\lstset{
  basicstyle=\fontspec{Courier New}\fontsize{12}{9.6}\selectfont,
  numbers=left,
  numberstyle=\scriptsize,
  breaklines=true,
  captionpos=b,
  frame=none,
  showstringspaces=false,
  xleftmargin=0.6cm,
}


% --------------------- DOCUMENT ---------------------
% ------- UPDATE HERE WITH CORRESPONDING VALUES - NAME & TITLE
\newcommand{\studentname}{Bertescu Andrei - 4LF721}
\newcommand{\projecttitle}{Proiect Sisteme Incorporate - Modulator Audio Controlat Prin Ethernet}

\begin{document}

% ------- THIS DOCUMENT IS MADE SEPARATELY AND ADDED HERE
% ------- NO NEED TO MODIFY HERE
\includepdf[pages=-, pagecommand={\thispagestyle{plainfooter}}]{Anexe/Prima pagina.pdf}

% ------- THE FOLLOWING PAGES ARE AUTOMATED - NO NEED TO MODIFY
\chapter*{Cuprins}
\vspace{-6em}
\tableofcontents
\newpage

\chapter*{Lista figurilor și tabelelor}
\addcontentsline{toc}{chapter}{Lista figurilor și tabelelor}

\section*{Figuri}
\vspace{-6em}
\listoffigures
% \newpage

\section*{Tabele}
\vspace{-6em}
\listoftables

% ------- THIS IS WHERE THE MAIN CONTENT GOES - EDIT HERE
\chapter{Rezumat}
Proiectul de față reprezintă un modulator de semnale audio implementat pe un FPGA din familia Artix-7 de la Xilinx, utilizând placa de dezvoltare Nexys Video de la Digilent. Sistemul folosește porturile audio ale plăcii pentru a prelucra un semnal audio cu frecvența de eșantionare de 48 kHz în diverse moduri și pentru a-l transmite ulterior către boxe sau căști. În plus, interfața Ethernet este folosită atât pentru transmiterea semnalului audio digital către un panou de comandă (dashboard), cât și pentru recepționarea setărilor necesare modificării procesării audio.

La celălalt capăt al cablului Ethernet se află un calculator pe care a fost implementat panoul de control în Python. Acesta permite monitorizarea semnalelor pe ambele canale, atât în domeniul timp, cât și în domeniul frecvență, și oferă acces la toate setările modulatorului printr-o interfață intuitivă. Utilizatorul poate ajusta amplitudinea, domeniul de vizualizare și diverși parametri pentru a observa cât mai clar semnalele audio.

Modulatorul configurat în FPGA poate executa o gamă largă de funcții: controlul volumului, introducerea de întârzieri pe fiecare canal, filtre trece-jos, trece-sus, trece-bandă și oprește-bandă, modulație în amplitudine și adăugarea de distorsiuni.

Configurația FPGA-ului include și mai multe module auxiliare pentru inițializarea și operarea corectă a plăcii. În FPGA sunt implementate generatoare de ceas pentru interfețele audio, Ethernet și pentru uz intern, un modul pentru configurarea inițială a cipului PHY responsabil de interfața Ethernet, precum și un modul pentru configurarea codec-ului audio. Aceste module funcționează prin iterarea unei liste de comenzi predefinite, transmise secvențial prin interfețele de configurare.

\newpage
\chapter{Introducere}
Proiectul implementează un modulator de semnale audio controlat prin Ethernet, realizat pe placa de dezvoltare Nexys Video, care integrează un FPGA din familia Artix-7. Sistemul preia un semnal audio printr-un cablu AUX, îl procesează conform setărilor primite de la un dashboard rulând pe un calculator conectat prin Ethernet, iar apoi transmite semnalul modificat către boxe externe sau căști.

Pe lângă cipul principal FPGA, proiectul utilizează două circuite externe pentru interfațarea cu dispozitivele periferice: codec-ul audio și cipul PHY responsabil de conexiunea Ethernet.

Operațiile de modificare posibile ale semnalului audio includ:
\begin{itemize}
  \item Filtrele elementare: trece-sus, trece-jos, trece-banda, oprește-bandă.
  \item Modulație în amplitudine.
  \item Controlul volumului pentru fiecare canal.
  \item Introducerea de întârzieri pe fiecare canal.
  \item Aplicare de distorsiuni.
\end{itemize}

Dashboard-ul de control permite monitorizarea în timp real a semnalelor audio pe ambele canale, atât în domeniul timp, cât și în domeniul frecvență, folosind transformata Fourier rapidă (FFT) \cite{fft}. Utilizatorul poate ajusta amplitudinea și fereastra de timp pentru o vizualizare optimă a semnalelor.

\section{Motivul alegerii temei}
Tema a fost aleasă pentru a demonstra capacitatea unui FPGA de a implementa circuite de procesare a semnalelor eficiente din punct de vedere al consumului de energie și cu latență redusă, precum și modul în care acesta poate integra o varietate de interfețe de comunicație într-o arhitectură flexibilă și modulară.

Totodată, proiectul a reprezentat o oportunitate de aprofundare a procesării audio, de învățare a modului de operare și programare a circuitelor externe, precum și de înțelegerea interfețelor Ethernet, MDIO, RGMII, I\textsuperscript{2}C și I\textsuperscript{2}S.

\newpage
\section{Prezentare platformă}
Platforma utilizată în proiect este placa de dezvoltare Nexys Video, produsă de Digilent \cite{nexys_video} și ilustrată în Figura \ref{fig:nexys_video}. Aceasta integrează ca dispozitiv principal FPGA-ul XC7A200T-1SBG484C din familia Artix-7, dezvoltată de Xilinx (parte a AMD). FPGA-ul oferă 215,360 elemente logice, 13,140 Kb de memorie BRAM și 740 blocuri DSP \cite{xmp101}, caracteristici care îl fac potrivit pentru aplicații de interfațare și procesare digitală a semnalelor.

Pe lângă FPGA, Nexys Video include o gamă variată de interfețe și porturi I/O. În cadrul proiectului au fost utilizate următoarele: interfața Ethernet, împreună cu cipul PHY RTL8211E-VL \cite{phy_chip}, un transceiver Gigabit produs de Realtek; două dintre porturile audio de intrare/ieșire, controlate de codec-ul ADAU1761 \cite{audio_codec} de la Analog Devices; un buton tactil pentru realizarea funcției de reset, precum și circuitele implicite de programare și alimentare ale plăcii (sursă externă de 12 V, 3 A).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\columnwidth]{./Images/nexys_video.png}
    \caption{Placa de dezvoltare Nexys Video.}%
\label{fig:nexys_video}
\end{figure}

\section{Schemă bloc}
Schema bloc a modulului principal este prezentată în Figura \ref{fig:block_diagram}. Aceasta include:

\begin{itemize}
\item \textbf{Blocul generator de ceasuri}. Conține mai multe IP-uri și divizoare de frecvență care generează, din ceasul principal de 100 MHz, semnalele necesare interfețelor Ethernet (25 MHz) și audio (30.72 MHz, 3.072 MHz, 48 kHz și 12.288 MHz).
\item \textbf{Blocul audio modulator}. Integrează interfața I\textsuperscript{2}S \cite{i2s} pentru recepția și transmiterea mostrelor audio, două memorii buffer pentru stocarea acestora și toate modulele de procesare (filtre, modulații, întârzieri, distorsiuni).
\item \textbf{Blocul de configurare al audio codec-ului}. Utilizează interfața I\textsuperscript{2}C pentru a seta registrul intern de control al cipului ADAU1761.
\item \textbf{Blocul de configurare al cipului PHY}. Utilizează interfața MDIO (similară ca structură cu I\textsuperscript{2}C) pentru configurarea registrelor interne ale transceiver-ului Ethernet RTL8211E-VL.
\item \textbf{Blocul de transmisie RGMII} \cite{rgmii}. Trimite mostrele audio procesate către calculator, unde sunt afișate în dashboard. Semnalul RGMII este convertit în Ethernet de către cipul PHY.
\item \textbf{Blocul de recepție RGMII}. Primește pachetele de configurare trimise din dashboard și actualizează registrele interne care controlează funcționarea modulatorului audio.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\columnwidth]{./Images/block_diagram.png}
    \caption{Schema bloc a configurării FPGA-ului.}%
\label{fig:block_diagram}
\end{figure}

\section{Bill of materials (BOM)}
Lista componentelor utilizate este prezentată în Tabelul \ref{tab:bom}. În afară de placa Nexys Video, proiectul nu necesită alte circuite active. Au fost folosite două cabluri (Ethernet și audio-in), o pereche de căști pentru monitorizarea semnalelor audio și un calculator pentru operarea dashboard-ului.

\begin{table}[ht!]
    \footnotesize
    \centering
    \renewcommand{\arraystretch}{1.6} 
    \caption{Bill of materials (BOM).}
    \label{tab:bom}
    \begin{tabular}{C{8,7cm} c C{3cm}}
		\toprule
			\textbf{Nume} & \textbf{Sursa} & \textbf{Preț - RON}\\
		\midrule
            Nexys Video & www.digilent.com & 2407  \\
            Cablu jack 3.5 mm AUX & www.emag.ro & 6  \\
            Cablu de rețea UTP Cat6 & www.emag.ro & 9  \\
            Calculator personal & - & -  \\
            Căști cu cablu AUX & - & -  \\
            \textbf{Total} & – & \textbf{2422} \\
		\bottomrule
    \end{tabular}
\end{table}

\section{Software utilizat}
Pentru dezvoltarea și programarea configurației FPGA a fost utilizat AMD Vivado 2024.1. Dashboard-ul de control a fost implementat în Python 3.13.3, folosind mediul de dezvoltare PyCharm 2024.3.4. Imaginile și schemele bloc au fost realizate cu ajutorul platformei Canva.com, iar o parte din măsurători au fost efectuate cu osciloscopul HDO9404-MS de la Teledyne LeCroy.

\chapter{Prezentare generală}
La resetarea FPGA-ului, fie la alimentare, fie prin apăsarea butonului de reset, sunt pornite modulele dedicate configurării cipului audio codec și ale cipului PHY. Sistemul așteaptă stabilizarea generatoarelor de ceas, după care sunt resetate cipurile externe și se programează regiștrii interni ai fiecăruia folosind interfețele I\textsuperscript{2}C \cite{i2c} și, respectiv, MDIO \cite{mdio}.

După finalizarea inițializării, sistemul intră în modul de funcționare activă. În această stare, semnalul audio circulă prin modulul audio\_modulator, este procesat conform setărilor alese și ulterior transmis înapoi către audio codec. În paralel, mostrele audio sunt transmise prin interfața Ethernet către calculator, unde sunt afișate în dashboard, iar eventualele modificări ale parametrilor de funcționare sunt recepționate și aplicate în timp real.

\section{Calea audio}
Calea parcursă de semnalul audio pe placa Nexys Video este prezentată în Figura \ref{fig:audio_flow_diagram}. În partea stângă sus a imaginii se regăsesc cei doi pini ai portului AUX, corespunzători canalelor stânga și dreapta. Semnalele analogice intră în audio codec, unde trec printr-un amplificator controlat în tensiune (PGA) setat la -6dB. Ulterior, sunt direcționate printr-un mixer de selecție a intrării și transformate în monstre digitale pe 24 de biți de către două convertoare Analog-Digital (ADC).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\columnwidth]{./Images/audio_flow_diagram.png}
    \caption{Calea parcursă de semnalul audio pe placa Nexys Video.}%
\label{fig:audio_flow_diagram}
\end{figure}

Datele digitale rezultate sunt transmise prin interfața I\textsuperscript{2}S către FPGA, unde sunt prelucrate de modulul audio\_modulator. Semnalul modificat este apoi trimis înapoi prin aceeași interfață către codec, unde parcurge operațiile inverse: conversia Digital-Analog (DAC), aplicarea unei atenuări de -12dB, trecerea prin mixerul de ieșire și amplificarea finală setată la 0dB.

Calea internă parcursă de semnal în modulul Verilog audio\_modulator este ilustrată în Figura \ref{fig:audio_modulator_diagram}. După ce cadrele I\textsuperscript{2}S sunt prelucrate, semnalul este injectat în modulele de procesare configurabile. Parametrii fiecărui modul pot fi modificați prin regiștri actualizați de dashboard, iar ieșirile sunt rutate către un mixer de selecție împreună cu semnalul original. Mixerul alege componenta finală în funcție de un registru dedicat.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{./Images/audio_modulator_diagram.png}
    \caption{Calea parcursă de semnalul audio în FPGA.}%
\label{fig:audio_modulator_diagram}
\end{figure}

Înainte de mixer se află două amplificatoare digitale, capabile să atenueze complet semnalul sau să îl amplifice până la un factor de 2 (strict în domeniul digital). Urmează buffer-ele de întârziere, implementate ca FIFO-uri cu capacitate de până la $2^{17}$ monstre. Pointerul de citire este programabil, ceea ce permite introducerea unei întârzieri maxime de aproximativ 2.73s. Ieșirea este apoi trecută printr-un shift-register și trimisă înapoi către codec.

Toți regiștrii de configurare sunt grupați într-un tablou care se actualizează la recepția fiecărei tranzacții Ethernet valide. Aceștia stochează selecția mixer-ului, frecvențele de tăiere ale filtrelor, frecvența de modulație în amplitudine, precum și volumul și întârzierea asociate fiecărui canal.

\newpage
\section{Blocurile de modulare}
În această secțiune sunt ilustrate modulele folosite pentru modificarea semnalului audio.

\subsection{Pass-through}
Semnalul nu este modificat în niciun fel, fiind direcționat direct către mixer. Parametrii care controlează comportamentul modulelor au fost calculați pe calculator și trimiși la FPGA în format fixed-point, pentru a reduce complexitatea. De asemenea, cele două canale audio au fost multiplexate în timp la intrarea modulelor pentru a economisi resurse de logice și DSP-uri.

\subsection{Filtru trece-jos}
Acest modul lasă să treacă frecvențele aflate sub un prag și atenuează frecvențele superioare. Ecuația utilizată este:
\[y[n] = \alpha \cdot x[n] + (1-\alpha) \cdot y[n-1]\]
Unde $\alpha$ este:
\[\alpha = 1 - e^{-2\pi \frac{f_{taiere}}{f_{esantionare}}}\]
Frecvența de eșantionare este de 48 kHz. Pentru a obține o pantă mai abruptă, filtrul a fost cascadat de două ori (ieșirea primului filtru intră în al doilea). Un exemplu este ilustrat în Figura \ref{fig:LP_2pole_5kHz}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{./Images/LP_2pole_5kHz.png}
    \caption{Spectrul de frecvențe pentru filtrul trece-jos cu frecvența de tăiere de 5 kHz.}%
\label{fig:LP_2pole_5kHz}
\end{figure}

\subsection{Filtru trece-sus}
Acest modul lasă să treacă frecvențele înalte și atenuează frecvențele joase. La fel ca filtrul trece-jos, este implementat în două etape cascadate. Ecuația utilizată este:
\[y[n] = \alpha \cdot y[n-1] + \frac{(1 + \alpha)}{2} \cdot (x[n] - x[n-1])\]
Unde $\alpha$ este:
\[\begin{aligned}
\alpha &= \frac{1 - k}{1 + k},  
k &= \tan\!\left(\pi \frac{f_{\text{taiere}}}{f_{\text{esantionare}}}\right)
\end{aligned}\]

\subsection{Filtru trece-bandă}
Filtrul obținut prin aplicarea în lanț a unui filtru trece-jos și a unuia trece-sus:
\[y_{\text{trece-banda}}[n] = y_{\text{trece-sus}}\Big(y_{\text{trece-jos}}(x[n])\Big)\]
Parametrii $\alpha_{jos}$ și $\alpha_{sus}$ stabilesc intervalul de frecvențe transmis fără atenuare.

\subsection{Filtru oprește-bandă}
Acest modul atenuează un interval restrâns de frecvențe, lăsând restul neatenuat:
\[y[n] = (x[n] + x[n-2] - \alpha \cdot x[n-1]) + (\alpha R \cdot y[n-1] - R^2 \cdot y[n-2])\]

Unde R controlează lățimea benzii eliminate (setat la câțiva Hz), iar $\alpha$ este:
\[\alpha = 2\cos\!\left(2\pi \frac{f_{taiere}}{f_{esantionare}}\right)\]

\subsection{Filtru distorsiune}
O simplă limitare a semnalului de o intensitate mai mare decât un prag, la pragul respectiv:
\[y[n] = \begin{cases}
{prag},   & x > {prag}, \\[4pt]
-{prag},  & x < -{prag}, \\[4pt]
x[n],        & \text{altfel}
\end{cases}\]

\subsection{Filtru tremolo - modulație în amplitudine}
Intensitatea semnalului audio este variată între 0 și 1 cu o frecvență prestabilită:
\[y[n] = x[n] \cdot \sin(\alpha)\]
Unde $\alpha$ reprezintă frecvența purtătoarei. Valorile sinusului au fost pre-calculate și stocate într-o memorie BRAM de 1024 de elemente. Aceste valori sunt normalizate în intervalul 0-1, iar parcurgerea lor se face cu un pas diferit în funcție de $\alpha$, astfel încât frecvența efectivă a modulației să corespundă valorii setate. Un exemplu este prezentat în Figura \ref{fig:AM_2}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\columnwidth]{./Images/AM_2.png}
    \caption{Filtrul de modulație în amplitudine cu frecvența purtătoarei de 5 Hz.}%
\label{fig:AM_2}
\end{figure}

\section{Dashboard}
Dashboard-ul este ilustrat în Figura \ref{fig:dashboard}. Acesta a fost dezvoltat în Python, utilizând bibliotecile NumPy, PyQt6 și Scapy. Aplicația rulează două fire de execuție active: unul se ocupă de recepția și transmiterea datelor prin interfața Ethernet, iar celălalt gestionează afișajul GUI. Cele două fire comunică printr-un buffer de date, prevenind astfel eventualele probleme de sincronizare.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{./Images/dashboard.png}
    \caption{Dashboard-ul de control în modul test.}%
\label{fig:dashboard}
\end{figure}

\chapter{Montaj}
Montajul proiectului este prezentat în Figura \ref{fig:montaj}. Acesta include placa Nexys Video în stânga, alimentată printr-o sursă externă de 12 V 3 A, conectată la un calculator prin Ethernet și portul audio. În plus, placa este conectată la o pereche de căști pentru redarea semnalului audio modificat.

Calculatorul transmite semnalul audio către placă și monitorizează procesarea acestuia prin dashboard-ul afișat pe ecran, permițând vizualizarea în timp real și modificarea parametrilor modulatorului.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{./Images/montaj.png}
    \caption{Montajul cu proiectul modulator audio.}%
\label{fig:montaj}
\end{figure}

\chapter{Concluzie}
În cadrul acestui proiect, am demonstrat posibilitatea implementării de la zero, într-un limbaj de descriere hardware (HDL), a diferitelor interfețe de comunicație seriale, precum și a unor metode diverse de procesare a semnalelor digitale.

Proiectul a permis acumularea de cunoștințe aprofundate despre procesarea semnalelor și despre protocoalele de comunicație Ethernet prin RGMII, precum și despre interfețele I\textsuperscript{2}S, I\textsuperscript{2}C și MDIO. De asemenea, am dezvoltat abilități în programarea Python, atât pentru crearea unei interfețe GUI intuitive, cât și pentru transmiterea și recepția pachetelor Ethernet.

Deși implementarea a fost un succes, există și limitări. Funcționarea plăcii Nexys Video depinde de o conexiune Ethernet corect configurată și de un calculator capabil să ruleze aplicația Python care generează dashboard-ul. Fără aceste elemente, modul de control al modulatorului nu este disponibil, iar semnalele audio rămân nemodificate. În plus, spectrul de frecvențe afișat este calculat pe calculator, și nu direct în hardware-ul FPGA, ceea ce ar fi mai eficient.

Cu toate acestea, proiectul a fost funcțional și stabil, testat cu diferite tipuri de semnal audio și pe mai multe dispozitive. Toate filtrele și modulele de modulare au răspuns corect în timp și frecvență, iar transferul de date prin Ethernet a rămas stabil pe perioade îndelungate.

% ------- BIBLIOGRAPHY IS AUTOMATED - NO NEED TO MODIFY
\nocite{*}
\printbibliography

\end{document}